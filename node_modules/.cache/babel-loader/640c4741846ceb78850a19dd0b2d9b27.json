{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash'),\n    Item = require('./item'),\n    Query = require('./query'),\n    Scan = require('./scan'),\n    EventEmitter = require('events').EventEmitter,\n    async = require('async'),\n    utils = require('./utils'),\n    ParallelScan = require('./parallelScan'),\n    expressions = require('./expressions');\n\nvar internals = {};\n\nvar Table = module.exports = function (name, schema, serializer, docClient, logger) {\n  this.config = {\n    name: name\n  };\n  this.schema = schema;\n  this.serializer = serializer;\n  this.docClient = docClient;\n  this.log = logger;\n  this._before = new EventEmitter();\n  this.before = this._before.on.bind(this._before);\n  this._after = new EventEmitter();\n  this.after = this._after.on.bind(this._after);\n};\n\nTable.prototype.initItem = function (attrs) {\n  var self = this;\n\n  if (self.itemFactory) {\n    return new self.itemFactory(attrs);\n  } else {\n    return new Item(attrs, self);\n  }\n};\n\nTable.prototype.tableName = function () {\n  if (this.schema.tableName) {\n    if (_.isFunction(this.schema.tableName)) {\n      return this.schema.tableName.call(this);\n    } else {\n      return this.schema.tableName;\n    }\n  } else {\n    return this.config.name;\n  }\n};\n\nTable.prototype.sendRequest = function (method, params, callback) {\n  var self = this;\n  var driver;\n\n  if (_.isFunction(self.docClient[method])) {\n    driver = self.docClient;\n  } else if (_.isFunction(self.docClient.service[method])) {\n    driver = self.docClient.service;\n  }\n\n  var startTime = Date.now();\n  self.log.info({\n    params: params\n  }, 'dynamo %s request', method.toUpperCase());\n  driver[method].call(driver, params, function (err, data) {\n    var elapsed = Date.now() - startTime;\n\n    if (err) {\n      self.log.warn({\n        err: err\n      }, 'dynamo %s error', method.toUpperCase());\n      return callback(err);\n    } else {\n      self.log.info({\n        data: data\n      }, 'dynamo %s response - %sms', method.toUpperCase(), elapsed);\n      return callback(null, data);\n    }\n  });\n};\n\nTable.prototype.get = function (hashKey, rangeKey, options, callback) {\n  var self = this;\n\n  if (_.isPlainObject(rangeKey) && typeof options === 'function' && !callback) {\n    callback = options;\n    options = rangeKey;\n    rangeKey = null;\n  } else if (typeof rangeKey === 'function' && !callback) {\n    callback = rangeKey;\n    options = {};\n    rangeKey = null;\n  } else if (typeof options === 'function' && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  var promise;\n\n  if (!callback && Promise) {\n    promise = new Promise(function (resolve, reject) {\n      callback = function (err, results) {\n        err ? reject(err) : resolve(results);\n      };\n    });\n  }\n\n  var params = {\n    TableName: self.tableName(),\n    Key: self.serializer.buildKey(hashKey, rangeKey, self.schema)\n  };\n  params = _.merge({}, params, options);\n  self.sendRequest('get', params, function (err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    var item = null;\n\n    if (data.Item) {\n      item = self.initItem(self.serializer.deserializeItem(data.Item));\n    }\n\n    return callback(null, item);\n  });\n  return promise;\n};\n\ninternals.callBeforeHooks = function (table, name, startFun, callback) {\n  var listeners = table._before.listeners(name);\n\n  return async.waterfall([startFun].concat(listeners), callback);\n};\n\nTable.prototype.create = function (item, options, callback) {\n  var self = this;\n\n  if (typeof options === 'function' && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  var promise;\n\n  if (!callback && Promise) {\n    promise = new Promise(function (resolve, reject) {\n      callback = function (err, results) {\n        err ? reject(err) : resolve(results);\n      };\n    });\n  }\n\n  callback = callback || _.noop;\n  options = options || {};\n\n  if (_.isArray(item)) {\n    async.map(item, function (data, callback) {\n      return internals.createItem(self, data, options, callback);\n    }, callback);\n  } else {\n    internals.createItem(self, item, options, callback);\n  }\n\n  return promise;\n};\n\ninternals.createItem = function (table, item, options, callback) {\n  var self = table;\n\n  var start = function (callback) {\n    var data = self.schema.applyDefaults(item);\n    var paramName = _.isString(self.schema.createdAt) ? self.schema.createdAt : 'createdAt';\n\n    if (self.schema.timestamps && self.schema.createdAt !== false && !_.has(data, paramName)) {\n      data[paramName] = new Date().toISOString();\n    }\n\n    return callback(null, data);\n  };\n\n  internals.callBeforeHooks(self, 'create', start, function (err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    var result = self.schema.validate(data);\n\n    if (result.error) {\n      return callback(result.error);\n    }\n\n    var attrs = utils.omitNulls(data);\n    var params = {\n      TableName: self.tableName(),\n      Item: self.serializer.serializeItem(self.schema, attrs)\n    };\n\n    if (options.expected) {\n      internals.addConditionExpression(params, options.expected);\n      options = _.omit(options, 'expected');\n    }\n\n    if (options.overwrite === false) {\n      var expected = _.chain([self.schema.hashKey, self.schema.rangeKey]).compact().reduce(function (result, key) {\n        _.set(result, key + '.<>', _.get(params.Item, key));\n\n        return result;\n      }, {}).value();\n\n      internals.addConditionExpression(params, expected);\n    }\n\n    options = _.omit(options, 'overwrite'); // remove overwrite flag regardless if true or false\n\n    params = _.merge({}, params, options);\n    self.sendRequest('put', params, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      var item = self.initItem(attrs);\n\n      self._after.emit('create', item);\n\n      return callback(null, item);\n    });\n  });\n};\n\ninternals.updateExpressions = function (schema, data, options) {\n  var exp = expressions.serializeUpdateExpression(schema, data);\n\n  if (options.UpdateExpression) {\n    var parsed = expressions.parse(options.UpdateExpression);\n    exp.expressions = _.reduce(parsed, function (result, val, key) {\n      if (!_.isEmpty(val)) {\n        result[key] = result[key].concat(val);\n      }\n\n      return result;\n    }, exp.expressions);\n  }\n\n  if (_.isPlainObject(options.ExpressionAttributeValues)) {\n    exp.values = _.merge({}, exp.values, options.ExpressionAttributeValues);\n  }\n\n  if (_.isPlainObject(options.ExpressionAttributeNames)) {\n    exp.attributeNames = _.merge({}, exp.attributeNames, options.ExpressionAttributeNames);\n  }\n\n  return _.merge({}, {\n    ExpressionAttributeValues: exp.values,\n    ExpressionAttributeNames: exp.attributeNames,\n    UpdateExpression: expressions.stringify(exp.expressions)\n  });\n};\n\nTable.prototype.update = function (item, options, callback) {\n  var self = this;\n\n  if (typeof options === 'function' && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  var promise;\n\n  if (!callback && Promise) {\n    promise = new Promise(function (resolve, reject) {\n      callback = function (err, results) {\n        err ? reject(err) : resolve(results);\n      };\n    });\n  }\n\n  callback = callback || _.noop;\n  options = options || {};\n\n  var start = function (callback) {\n    var paramName = _.isString(self.schema.updatedAt) ? self.schema.updatedAt : 'updatedAt';\n\n    if (self.schema.timestamps && self.schema.updatedAt !== false && !_.has(item, paramName)) {\n      item[paramName] = new Date().toISOString();\n    }\n\n    return callback(null, item);\n  };\n\n  internals.callBeforeHooks(self, 'update', start, function (err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    var hashKey = data[self.schema.hashKey];\n    var rangeKey = data[self.schema.rangeKey] || null;\n    var params = {\n      TableName: self.tableName(),\n      Key: self.serializer.buildKey(hashKey, rangeKey, self.schema),\n      ReturnValues: 'ALL_NEW'\n    };\n    var exp = internals.updateExpressions(self.schema, data, options);\n\n    if (exp.UpdateExpression) {\n      params.UpdateExpression = exp.UpdateExpression;\n      delete options.UpdateExpression;\n    }\n\n    if (exp.ExpressionAttributeValues) {\n      params.ExpressionAttributeValues = exp.ExpressionAttributeValues;\n      delete options.ExpressionAttributeValues;\n    }\n\n    if (exp.ExpressionAttributeNames) {\n      params.ExpressionAttributeNames = exp.ExpressionAttributeNames;\n      delete options.ExpressionAttributeNames;\n    }\n\n    if (options.expected) {\n      internals.addConditionExpression(params, options.expected);\n      delete options.expected;\n    }\n\n    params = _.chain({}).merge(params, options).omitBy(_.isEmpty).value();\n    self.sendRequest('update', params, function (err, data) {\n      if (err) {\n        return callback(err);\n      }\n\n      var result = null;\n\n      if (data.Attributes) {\n        result = self.initItem(self.serializer.deserializeItem(data.Attributes));\n      }\n\n      self._after.emit('update', result);\n\n      return callback(null, result);\n    });\n  });\n  return promise;\n};\n\ninternals.addConditionExpression = function (params, expectedConditions) {\n  _.each(expectedConditions, function (val, key) {\n    var operator;\n    var expectedValue = null;\n\n    var existingValueKeys = _.keys(params.ExpressionAttributeValues);\n\n    if (_.isObject(val) && _.isBoolean(val.Exists) && val.Exists === true) {\n      operator = 'attribute_exists';\n    } else if (_.isObject(val) && _.isBoolean(val.Exists) && val.Exists === false) {\n      operator = 'attribute_not_exists';\n    } else if (_.isObject(val) && _.has(val, '<>')) {\n      operator = '<>';\n      expectedValue = _.get(val, '<>');\n    } else {\n      operator = '=';\n      expectedValue = val;\n    }\n\n    var condition = expressions.buildFilterExpression(key, operator, existingValueKeys, expectedValue, null);\n    params.ExpressionAttributeNames = _.merge({}, condition.attributeNames, params.ExpressionAttributeNames);\n    params.ExpressionAttributeValues = _.merge({}, condition.attributeValues, params.ExpressionAttributeValues);\n\n    if (_.isString(params.ConditionExpression)) {\n      params.ConditionExpression = params.ConditionExpression + ' AND (' + condition.statement + ')';\n    } else {\n      params.ConditionExpression = '(' + condition.statement + ')';\n    }\n  });\n};\n\nTable.prototype.destroy = function (hashKey, rangeKey, options, callback) {\n  var self = this;\n\n  if (_.isPlainObject(rangeKey) && typeof options === 'function' && !callback) {\n    callback = options;\n    options = rangeKey;\n    rangeKey = null;\n  } else if (typeof rangeKey === 'function' && !callback) {\n    callback = rangeKey;\n    options = {};\n    rangeKey = null;\n  } else if (_.isPlainObject(rangeKey) && !callback) {\n    callback = options;\n    options = rangeKey;\n    rangeKey = null;\n  } else if (typeof options === 'function' && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  var promise;\n\n  if (!callback && Promise) {\n    promise = new Promise(function (resolve, reject) {\n      callback = function (err, results) {\n        err ? reject(err) : resolve(results);\n      };\n    });\n  }\n\n  callback = callback || _.noop;\n  options = options || {};\n\n  if (_.isPlainObject(hashKey)) {\n    rangeKey = hashKey[self.schema.rangeKey] || null;\n    hashKey = hashKey[self.schema.hashKey];\n  }\n\n  var params = {\n    TableName: self.tableName(),\n    Key: self.serializer.buildKey(hashKey, rangeKey, self.schema)\n  };\n\n  if (options.expected) {\n    internals.addConditionExpression(params, options.expected);\n    delete options.expected;\n  }\n\n  params = _.merge({}, params, options);\n  self.sendRequest('delete', params, function (err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    var item = null;\n\n    if (data.Attributes) {\n      item = self.initItem(self.serializer.deserializeItem(data.Attributes));\n    }\n\n    self._after.emit('destroy', item);\n\n    return callback(null, item);\n  });\n  return promise;\n};\n\nTable.prototype.query = function (hashKey) {\n  var self = this;\n  return new Query(hashKey, self, self.serializer);\n};\n\nTable.prototype.scan = function () {\n  var self = this;\n  return new Scan(self, self.serializer);\n};\n\nTable.prototype.parallelScan = function (totalSegments) {\n  var self = this;\n  return new ParallelScan(self, self.serializer, totalSegments);\n};\n\ninternals.deserializeItems = function (table, callback) {\n  return function (err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    var result = {};\n\n    if (data.Items) {\n      result.Items = _.map(data.Items, function (i) {\n        return table.initItem(table.serializer.deserializeItem(i));\n      });\n      delete data.Items;\n    }\n\n    if (data.LastEvaluatedKey) {\n      result.LastEvaluatedKey = data.LastEvaluatedKey;\n      delete data.LastEvaluatedKey;\n    }\n\n    return callback(null, _.merge({}, data, result));\n  };\n};\n\nTable.prototype.runQuery = function (params, callback) {\n  var self = this;\n  self.sendRequest('query', params, internals.deserializeItems(self, callback));\n};\n\nTable.prototype.runScan = function (params, callback) {\n  var self = this;\n  self.sendRequest('scan', params, internals.deserializeItems(self, callback));\n};\n\nTable.prototype.runBatchGetItems = function (params, callback) {\n  var self = this;\n  self.sendRequest('batchGet', params, callback);\n};\n\ninternals.attributeDefinition = function (schema, key) {\n  var type = schema._modelDatatypes[key];\n\n  if (type === 'DATE') {\n    type = 'S';\n  }\n\n  return {\n    AttributeName: key,\n    AttributeType: type\n  };\n};\n\ninternals.keySchema = function (hashKey, rangeKey) {\n  var result = [{\n    AttributeName: hashKey,\n    KeyType: 'HASH'\n  }];\n\n  if (rangeKey) {\n    result.push({\n      AttributeName: rangeKey,\n      KeyType: 'RANGE'\n    });\n  }\n\n  return result;\n};\n\ninternals.secondaryIndex = function (schema, params) {\n  var projection = params.projection || {\n    ProjectionType: 'ALL'\n  };\n  return {\n    IndexName: params.name,\n    KeySchema: internals.keySchema(schema.hashKey, params.rangeKey),\n    Projection: projection\n  };\n};\n\ninternals.globalIndex = function (indexName, params) {\n  var projection = params.projection || {\n    ProjectionType: 'ALL'\n  };\n  return {\n    IndexName: indexName,\n    KeySchema: internals.keySchema(params.hashKey, params.rangeKey),\n    Projection: projection,\n    ProvisionedThroughput: {\n      ReadCapacityUnits: params.readCapacity || 1,\n      WriteCapacityUnits: params.writeCapacity || 1\n    }\n  };\n};\n\nTable.prototype.createTable = function (options, callback) {\n  var self = this;\n\n  if (typeof options === 'function' && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  var attributeDefinitions = [];\n  attributeDefinitions.push(internals.attributeDefinition(self.schema, self.schema.hashKey));\n\n  if (self.schema.rangeKey) {\n    attributeDefinitions.push(internals.attributeDefinition(self.schema, self.schema.rangeKey));\n  }\n\n  var localSecondaryIndexes = [];\n\n  _.forEach(self.schema.secondaryIndexes, function (params) {\n    attributeDefinitions.push(internals.attributeDefinition(self.schema, params.rangeKey));\n    localSecondaryIndexes.push(internals.secondaryIndex(self.schema, params));\n  });\n\n  var globalSecondaryIndexes = [];\n\n  _.forEach(self.schema.globalIndexes, function (params, indexName) {\n    if (!_.find(attributeDefinitions, {\n      'AttributeName': params.hashKey\n    })) {\n      attributeDefinitions.push(internals.attributeDefinition(self.schema, params.hashKey));\n    }\n\n    if (params.rangeKey && !_.find(attributeDefinitions, {\n      'AttributeName': params.rangeKey\n    })) {\n      attributeDefinitions.push(internals.attributeDefinition(self.schema, params.rangeKey));\n    }\n\n    globalSecondaryIndexes.push(internals.globalIndex(indexName, params));\n  });\n\n  var keySchema = internals.keySchema(self.schema.hashKey, self.schema.rangeKey);\n  var params = {\n    AttributeDefinitions: attributeDefinitions,\n    TableName: self.tableName(),\n    KeySchema: keySchema,\n    ProvisionedThroughput: {\n      ReadCapacityUnits: options.readCapacity || 1,\n      WriteCapacityUnits: options.writeCapacity || 1\n    }\n  };\n\n  if (localSecondaryIndexes.length >= 1) {\n    params.LocalSecondaryIndexes = localSecondaryIndexes;\n  }\n\n  if (globalSecondaryIndexes.length >= 1) {\n    params.GlobalSecondaryIndexes = globalSecondaryIndexes;\n  }\n\n  self.sendRequest('createTable', params, callback);\n};\n\nTable.prototype.describeTable = function (callback) {\n  var promise;\n\n  if (!callback && Promise) {\n    promise = new Promise(function (resolve, reject) {\n      callback = function (err, results) {\n        err ? reject(err) : resolve(results);\n      };\n    });\n  }\n\n  var params = {\n    TableName: this.tableName()\n  };\n  this.sendRequest('describeTable', params, callback);\n  return promise;\n};\n\nTable.prototype.deleteTable = function (callback) {\n  var promise;\n\n  if (!callback && Promise) {\n    promise = new Promise(function (resolve, reject) {\n      callback = function (err) {\n        err ? reject(err) : resolve();\n      };\n    });\n  }\n\n  callback = callback || _.noop;\n  var params = {\n    TableName: this.tableName()\n  };\n  this.sendRequest('deleteTable', params, callback);\n  return promise;\n};\n\nTable.prototype.updateTable = function (throughput, callback) {\n  var self = this;\n\n  if (typeof throughput === 'function' && !callback) {\n    callback = throughput;\n    throughput = {};\n  }\n\n  var promise;\n\n  if (!callback && Promise) {\n    promise = new Promise(function (resolve, reject) {\n      callback = function (err) {\n        err ? reject(err) : resolve();\n      };\n    });\n  }\n\n  callback = callback || _.noop;\n  throughput = throughput || {};\n  async.parallel([async.apply(internals.syncIndexes, self), async.apply(internals.updateTableCapacity, self, throughput)], callback);\n  return promise;\n};\n\ninternals.updateTableCapacity = function (table, throughput, callback) {\n  var params = {};\n\n  if (_.has(throughput, 'readCapacity') || _.has(throughput, 'writeCapacity')) {\n    params.ProvisionedThroughput = {};\n\n    if (_.has(throughput, 'readCapacity')) {\n      params.ProvisionedThroughput.ReadCapacityUnits = throughput.readCapacity;\n    }\n\n    if (_.has(throughput, 'writeCapacity')) {\n      params.ProvisionedThroughput.WriteCapacityUnits = throughput.writeCapacity;\n    }\n  }\n\n  if (!_.isEmpty(params)) {\n    params.TableName = table.tableName();\n    table.sendRequest('updateTable', params, callback);\n  } else {\n    callback();\n  }\n};\n\ninternals.syncIndexes = function (table, callback) {\n  callback = callback || _.noop;\n  table.describeTable(function (err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    var missing = _.values(internals.findMissingGlobalIndexes(table, data));\n\n    if (_.isEmpty(missing)) {\n      return callback();\n    } // UpdateTable only allows one new index per UpdateTable call\n    // http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.OnlineOps.html#GSI.OnlineOps.Creating\n\n\n    var maxIndexCreationsAtaTime = 5;\n    async.mapLimit(missing, maxIndexCreationsAtaTime, function (params, callback) {\n      var attributeDefinitions = [];\n\n      if (!_.find(attributeDefinitions, {\n        'AttributeName': params.hashKey\n      })) {\n        attributeDefinitions.push(internals.attributeDefinition(table.schema, params.hashKey));\n      }\n\n      if (params.rangeKey && !_.find(attributeDefinitions, {\n        'AttributeName': params.rangeKey\n      })) {\n        attributeDefinitions.push(internals.attributeDefinition(table.schema, params.rangeKey));\n      }\n\n      var currentWriteThroughput = data.Table.ProvisionedThroughput.WriteCapacityUnits;\n\n      var newIndexWriteThroughput = _.ceil(currentWriteThroughput * 1.5);\n\n      params.writeCapacity = params.writeCapacity || newIndexWriteThroughput;\n      table.log.info('adding index %s to table %s', params.name, table.tableName());\n      var updateParams = {\n        TableName: table.tableName(),\n        AttributeDefinitions: attributeDefinitions,\n        GlobalSecondaryIndexUpdates: [{\n          Create: internals.globalIndex(params.name, params)\n        }]\n      };\n      table.sendRequest('updateTable', updateParams, callback);\n    }, callback);\n  });\n};\n\ninternals.findMissingGlobalIndexes = function (table, data) {\n  if (_.isNull(data) || _.isUndefined(data)) {\n    // table does not exist \n    return table.schema.globalIndexes;\n  } else {\n    var indexData = _.get(data, 'Table.GlobalSecondaryIndexes');\n\n    var existingIndexNames = _.map(indexData, 'IndexName');\n\n    var missing = _.reduce(table.schema.globalIndexes, function (result, idx, indexName) {\n      if (!_.includes(existingIndexNames, idx.name)) {\n        result[indexName] = idx;\n      }\n\n      return result;\n    }, {});\n\n    return missing;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}