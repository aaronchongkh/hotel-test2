{"ast":null,"code":"var fs = require('fs'),\n    path = require('path');\n\nmodule.exports = ncp;\nncp.ncp = ncp;\n\nfunction ncp(source, dest, options, callback) {\n  var cback = callback;\n\n  if (!callback) {\n    cback = options;\n    options = {};\n  }\n\n  var basePath = process.cwd(),\n      currentPath = path.resolve(basePath, source),\n      targetPath = path.resolve(basePath, dest),\n      filter = options.filter,\n      rename = options.rename,\n      transform = options.transform,\n      clobber = options.clobber !== false,\n      modified = options.modified,\n      dereference = options.dereference,\n      errs = null,\n      started = 0,\n      finished = 0,\n      running = 0,\n      limit = options.limit || ncp.limit || 16;\n  limit = limit < 1 ? 1 : limit > 512 ? 512 : limit;\n  startCopy(currentPath);\n\n  function startCopy(source) {\n    started++;\n\n    if (filter) {\n      if (filter instanceof RegExp) {\n        if (!filter.test(source)) {\n          return cb(true);\n        }\n      } else if (typeof filter === 'function') {\n        if (!filter(source)) {\n          return cb(true);\n        }\n      }\n    }\n\n    return getStats(source);\n  }\n\n  function getStats(source) {\n    var stat = dereference ? fs.stat : fs.lstat;\n\n    if (running >= limit) {\n      return setImmediate(function () {\n        getStats(source);\n      });\n    }\n\n    running++;\n    stat(source, function (err, stats) {\n      var item = {};\n\n      if (err) {\n        return onError(err);\n      } // We need to get the mode from the stats object and preserve it.\n\n\n      item.name = source;\n      item.mode = stats.mode;\n      item.mtime = stats.mtime; //modified time\n\n      item.atime = stats.atime; //access time\n\n      if (stats.isDirectory()) {\n        return onDir(item);\n      } else if (stats.isFile()) {\n        return onFile(item);\n      } else if (stats.isSymbolicLink()) {\n        // Symlinks don't really need to know about the mode.\n        return onLink(source);\n      }\n    });\n  }\n\n  function onFile(file) {\n    var target = file.name.replace(currentPath, targetPath);\n\n    if (rename) {\n      target = rename(target);\n    }\n\n    isWritable(target, function (writable) {\n      if (writable) {\n        return copyFile(file, target);\n      }\n\n      if (clobber) {\n        rmFile(target, function () {\n          copyFile(file, target);\n        });\n      }\n\n      if (modified) {\n        var stat = dereference ? fs.stat : fs.lstat;\n        stat(target, function (err, stats) {\n          //if souce modified time greater to target modified time copy file\n          if (file.mtime.getTime() > stats.mtime.getTime()) copyFile(file, target);else return cb();\n        });\n      } else {\n        return cb();\n      }\n    });\n  }\n\n  function copyFile(file, target) {\n    var readStream = fs.createReadStream(file.name),\n        writeStream = fs.createWriteStream(target, {\n      mode: file.mode\n    });\n    readStream.on('error', onError);\n    writeStream.on('error', onError);\n\n    if (transform) {\n      transform(readStream, writeStream, file);\n    } else {\n      writeStream.on('open', function () {\n        readStream.pipe(writeStream);\n      });\n    }\n\n    writeStream.once('finish', function () {\n      if (modified) {\n        //target file modified date sync.\n        fs.utimesSync(target, file.atime, file.mtime);\n        cb();\n      } else cb();\n    });\n  }\n\n  function rmFile(file, done) {\n    fs.unlink(file, function (err) {\n      if (err) {\n        return onError(err);\n      }\n\n      return done();\n    });\n  }\n\n  function onDir(dir) {\n    var target = dir.name.replace(currentPath, targetPath);\n    isWritable(target, function (writable) {\n      if (writable) {\n        return mkDir(dir, target);\n      }\n\n      copyDir(dir.name);\n    });\n  }\n\n  function mkDir(dir, target) {\n    fs.mkdir(target, dir.mode, function (err) {\n      if (err) {\n        return onError(err);\n      }\n\n      copyDir(dir.name);\n    });\n  }\n\n  function copyDir(dir) {\n    fs.readdir(dir, function (err, items) {\n      if (err) {\n        return onError(err);\n      }\n\n      items.forEach(function (item) {\n        startCopy(path.join(dir, item));\n      });\n      return cb();\n    });\n  }\n\n  function onLink(link) {\n    var target = link.replace(currentPath, targetPath);\n    fs.readlink(link, function (err, resolvedPath) {\n      if (err) {\n        return onError(err);\n      }\n\n      checkLink(resolvedPath, target);\n    });\n  }\n\n  function checkLink(resolvedPath, target) {\n    if (dereference) {\n      resolvedPath = path.resolve(basePath, resolvedPath);\n    }\n\n    isWritable(target, function (writable) {\n      if (writable) {\n        return makeLink(resolvedPath, target);\n      }\n\n      fs.readlink(target, function (err, targetDest) {\n        if (err) {\n          return onError(err);\n        }\n\n        if (dereference) {\n          targetDest = path.resolve(basePath, targetDest);\n        }\n\n        if (targetDest === resolvedPath) {\n          return cb();\n        }\n\n        return rmFile(target, function () {\n          makeLink(resolvedPath, target);\n        });\n      });\n    });\n  }\n\n  function makeLink(linkPath, target) {\n    fs.symlink(linkPath, target, function (err) {\n      if (err) {\n        return onError(err);\n      }\n\n      return cb();\n    });\n  }\n\n  function isWritable(path, done) {\n    fs.lstat(path, function (err) {\n      if (err) {\n        if (err.code === 'ENOENT') return done(true);\n        return done(false);\n      }\n\n      return done(false);\n    });\n  }\n\n  function onError(err) {\n    if (options.stopOnError) {\n      return cback(err);\n    } else if (!errs && options.errs) {\n      errs = fs.createWriteStream(options.errs);\n    } else if (!errs) {\n      errs = [];\n    }\n\n    if (typeof errs.write === 'undefined') {\n      errs.push(err);\n    } else {\n      errs.write(err.stack + '\\n\\n');\n    }\n\n    return cb();\n  }\n\n  function cb(skipped) {\n    if (!skipped) running--;\n    finished++;\n\n    if (started === finished && running === 0) {\n      if (cback !== undefined) {\n        return errs ? cback(errs) : cback(null);\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}