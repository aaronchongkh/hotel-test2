{"ast":null,"code":"'use strict';\n\nconst Ref = require('./ref');\n\nmodule.exports = class Set {\n  constructor() {\n    this._set = [];\n  }\n\n  add(value, refs) {\n    if (!Ref.isRef(value) && this.has(value, null, null, false)) {\n      return;\n    }\n\n    if (refs !== undefined) {\n      // If it's a merge, we don't have any refs\n      Ref.push(refs, value);\n    }\n\n    this._set.push(value);\n\n    return this;\n  }\n\n  merge(add, remove) {\n    for (let i = 0; i < add._set.length; ++i) {\n      this.add(add._set[i]);\n    }\n\n    for (let i = 0; i < remove._set.length; ++i) {\n      this.remove(remove._set[i]);\n    }\n\n    return this;\n  }\n\n  remove(value) {\n    this._set = this._set.filter(item => value !== item);\n    return this;\n  }\n\n  has(value, state, options, insensitive) {\n    for (let i = 0; i < this._set.length; ++i) {\n      let items = this._set[i];\n\n      if (state && Ref.isRef(items)) {\n        // Only resolve references if there is a state, otherwise it's a merge\n        items = items(state.reference || state.parent, options);\n      }\n\n      if (!Array.isArray(items)) {\n        items = [items];\n      }\n\n      for (let j = 0; j < items.length; ++j) {\n        const item = items[j];\n\n        if (typeof value !== typeof item) {\n          continue;\n        }\n\n        if (value === item || value instanceof Date && item instanceof Date && value.getTime() === item.getTime() || insensitive && typeof value === 'string' && value.toLowerCase() === item.toLowerCase() || Buffer.isBuffer(value) && Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary')) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  values(options) {\n    if (options && options.stripUndefined) {\n      const values = [];\n\n      for (let i = 0; i < this._set.length; ++i) {\n        const item = this._set[i];\n\n        if (item !== undefined) {\n          values.push(item);\n        }\n      }\n\n      return values;\n    }\n\n    return this._set.slice();\n  }\n\n  slice() {\n    const newSet = new Set();\n    newSet._set = this._set.slice();\n    return newSet;\n  }\n\n  concat(source) {\n    const newSet = new Set();\n    newSet._set = this._set.concat(source._set);\n    return newSet;\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}