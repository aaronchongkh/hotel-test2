{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash'),\n    async = require('async');\n\nvar internals = {};\n\ninternals.buildInitialGetItemsRequest = function (tableName, keys, options) {\n  var request = {};\n  request[tableName] = _.merge({}, {\n    Keys: keys\n  }, options);\n  return {\n    RequestItems: request\n  };\n};\n\ninternals.serializeKeys = function (keys, table, serializer) {\n  return keys.map(function (key) {\n    return serializer.buildKey(key, null, table.schema);\n  });\n};\n\ninternals.mergeResponses = function (tableName, responses) {\n  var base = {\n    Responses: {},\n    ConsumedCapacity: []\n  };\n  base.Responses[tableName] = [];\n  return responses.reduce(function (memo, resp) {\n    if (resp.Responses && resp.Responses[tableName]) {\n      memo.Responses[tableName] = memo.Responses[tableName].concat(resp.Responses[tableName]);\n    }\n\n    return memo;\n  }, base);\n};\n\ninternals.paginatedRequest = function (request, table, callback) {\n  var responses = [];\n\n  var doFunc = function (callback) {\n    table.runBatchGetItems(request, function (err, resp) {\n      if (err && err.retryable) {\n        return callback();\n      } else if (err) {\n        return callback(err);\n      }\n\n      request = resp.UnprocessedKeys;\n      responses.push(resp);\n      return callback();\n    });\n  };\n\n  var testFunc = function () {\n    return request !== null && !_.isEmpty(request);\n  };\n\n  var resulsFunc = function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, internals.mergeResponses(table.tableName(), responses));\n  };\n\n  async.doWhilst(doFunc, testFunc, resulsFunc);\n};\n\ninternals.buckets = function (keys) {\n  var buckets = [];\n\n  while (keys.length) {\n    buckets.push(keys.splice(0, 100));\n  }\n\n  return buckets;\n};\n\ninternals.initialBatchGetItems = function (keys, table, serializer, options, callback) {\n  var serializedKeys = internals.serializeKeys(keys, table, serializer);\n  var request = internals.buildInitialGetItemsRequest(table.tableName(), serializedKeys, options);\n  internals.paginatedRequest(request, table, function (err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    var dynamoItems = data.Responses[table.tableName()];\n\n    var items = _.map(dynamoItems, function (i) {\n      return table.initItem(serializer.deserializeItem(i));\n    });\n\n    return callback(null, items);\n  });\n};\n\ninternals.getItems = function (table, serializer) {\n  return function (keys, options, callback) {\n    if (typeof options === 'function' && !callback) {\n      callback = options;\n      options = {};\n    }\n\n    var promise;\n\n    if (Promise && typeof callback !== 'function') {\n      promise = new Promise(function (resolve, reject) {\n        callback = function (err, results) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(results);\n          }\n        };\n      });\n    }\n\n    async.map(internals.buckets(_.clone(keys)), function (key, callback) {\n      internals.initialBatchGetItems(key, table, serializer, options, callback);\n    }, function (err, results) {\n      if (err) {\n        return callback(err);\n      }\n\n      return callback(null, _.flatten(results));\n    });\n    return promise;\n  };\n};\n\nmodule.exports = function (table, serializer) {\n  return {\n    getItems: internals.getItems(table, serializer)\n  };\n};","map":null,"metadata":{},"sourceType":"script"}