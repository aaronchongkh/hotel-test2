{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash'),\n    utils = require('./utils'),\n    serializer = require('./serializer');\n\nvar internals = {};\ninternals.actionWords = ['SET', 'ADD', 'REMOVE', 'DELETE'];\ninternals.regexMap = _.reduce(internals.actionWords, function (result, key) {\n  result[key] = new RegExp(key + '\\\\s*(.+?)\\\\s*(SET|ADD|REMOVE|DELETE|$)');\n  return result;\n}, {}); // explanation http://stackoverflow.com/questions/3428618/regex-to-find-commas-that-arent-inside-and\n\ninternals.splitOperandsRegex = new RegExp(/\\s*(?![^(]*\\)),\\s*/);\n\ninternals.match = function (actionWord, str) {\n  var match = internals.regexMap[actionWord].exec(str);\n\n  if (match && match.length >= 2) {\n    return match[1].split(internals.splitOperandsRegex);\n  } else {\n    return null;\n  }\n};\n\nexports.parse = function (str) {\n  return _.reduce(internals.actionWords, function (result, actionWord) {\n    result[actionWord] = internals.match(actionWord, str);\n    return result;\n  }, {});\n};\n\nexports.serializeUpdateExpression = function (schema, item) {\n  var datatypes = schema._modelDatatypes;\n  var data = utils.omitPrimaryKeys(schema, item);\n  var memo = {\n    expressions: {},\n    attributeNames: {},\n    values: {}\n  };\n  memo.expressions = _.reduce(internals.actionWords, function (result, key) {\n    result[key] = [];\n    return result;\n  }, {});\n\n  var result = _.reduce(data, function (result, value, key) {\n    var valueKey = ':' + key;\n    var nameKey = '#' + key;\n\n    if (_.isNull(value) || _.isString(value) && _.isEmpty(value)) {\n      result.expressions.REMOVE.push(nameKey);\n      result.attributeNames[nameKey] = key;\n    } else if (_.isPlainObject(value) && value.$add) {\n      result.expressions.ADD.push(nameKey + ' ' + valueKey);\n      result.values[valueKey] = serializer.serializeAttribute(value.$add, datatypes[key]);\n      result.attributeNames[nameKey] = key;\n    } else if (_.isPlainObject(value) && value.$del) {\n      result.expressions.DELETE.push(nameKey + ' ' + valueKey);\n      result.values[valueKey] = serializer.serializeAttribute(value.$del, datatypes[key]);\n      result.attributeNames[nameKey] = key;\n    } else {\n      result.expressions.SET.push(nameKey + ' = ' + valueKey);\n      result.values[valueKey] = serializer.serializeAttribute(value, datatypes[key]);\n      result.attributeNames[nameKey] = key;\n    }\n\n    return result;\n  }, memo);\n\n  return result;\n};\n\nexports.stringify = function (expressions) {\n  return _.reduce(expressions, function (result, value, key) {\n    if (!_.isEmpty(value)) {\n      if (_.isArray(value)) {\n        result.push(key + ' ' + value.join(', '));\n      } else {\n        result.push(key + ' ' + value);\n      }\n    }\n\n    return result;\n  }, []).join(' ');\n};\n\ninternals.formatAttributeValue = function (val) {\n  if (_.isDate(val)) {\n    return val.toISOString();\n  }\n\n  return val;\n};\n\ninternals.isFunctionOperator = function (operator) {\n  return _.includes(['attribute_exists', 'attribute_not_exists', 'attribute_type', 'begins_with', 'contains', 'NOT contains', 'size'], operator);\n};\n\ninternals.uniqAttributeValueName = function (key, existingValueNames) {\n  var potentialName = ':' + key;\n  var idx = 1;\n\n  while (_.includes(existingValueNames, potentialName)) {\n    idx++;\n    potentialName = ':' + key + '_' + idx;\n  }\n\n  return potentialName;\n};\n\nexports.buildFilterExpression = function (key, operator, existingValueNames, val1, val2) {\n  // IN filter expression is unlike all the others where val1 is an array of values\n  if (operator === 'IN') {\n    return internals.buildInFilterExpression(key, existingValueNames, val1);\n  }\n\n  var v1 = internals.formatAttributeValue(val1);\n  var v2 = internals.formatAttributeValue(val2);\n\n  if (operator === 'attribute_exists' && v1 === false) {\n    operator = 'attribute_not_exists';\n    v1 = null;\n  } else if (operator === 'attribute_exists' && v1 === true) {\n    v1 = null;\n  }\n\n  var path = '#' + key;\n  var v1ValueName = internals.uniqAttributeValueName(key, existingValueNames);\n  var v2ValueName = internals.uniqAttributeValueName(key, [v1ValueName].concat(existingValueNames));\n  var statement = '';\n\n  if (internals.isFunctionOperator(operator)) {\n    if (!_.isNull(v1) && !_.isUndefined(v1)) {\n      statement = operator + '(' + path + ', ' + v1ValueName + ')';\n    } else {\n      statement = operator + '(' + path + ')';\n    }\n  } else if (operator === 'BETWEEN') {\n    statement = path + ' BETWEEN ' + v1ValueName + ' AND ' + v2ValueName;\n  } else {\n    statement = [path, operator, v1ValueName].join(' ');\n  }\n\n  var attributeValues = {};\n\n  if (!_.isNull(v1) && !_.isUndefined(v1)) {\n    attributeValues[v1ValueName] = v1;\n  }\n\n  if (!_.isNull(v2) && !_.isUndefined(v2)) {\n    attributeValues[v2ValueName] = v2;\n  }\n\n  var attributeNames = {};\n  attributeNames[path] = key;\n  return {\n    attributeNames: attributeNames,\n    statement: statement,\n    attributeValues: attributeValues\n  };\n};\n\ninternals.buildInFilterExpression = function (key, existingValueNames, values) {\n  var path = '#' + key;\n  var attributeNames = {};\n  attributeNames[path] = key;\n\n  var attributeValues = _.reduce(values, function (result, val) {\n    var existing = _.keys(result).concat(existingValueNames);\n\n    var p = internals.uniqAttributeValueName(key, existing);\n    result[p] = internals.formatAttributeValue(val);\n    return result;\n  }, {});\n\n  return {\n    attributeNames: attributeNames,\n    statement: path + ' IN (' + _.keys(attributeValues) + ')',\n    attributeValues: attributeValues\n  };\n};","map":null,"metadata":{},"sourceType":"script"}