{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash'),\n    expressions = require('./expressions'),\n    utils = require('./utils');\n\nvar internals = {};\n\ninternals.keyCondition = function (keyName, schema, scan) {\n  var f = function (operator) {\n    return function ()\n    /*values*/\n    {\n      var copy = [].slice.call(arguments);\n\n      var existingValueKeys = _.keys(scan.request.ExpressionAttributeValues);\n\n      var args = [keyName, operator, existingValueKeys].concat(copy);\n      var cond = expressions.buildFilterExpression.apply(null, args);\n      return scan.addFilterCondition(cond);\n    };\n  };\n\n  return {\n    equals: f('='),\n    eq: f('='),\n    ne: f('<>'),\n    lte: f('<='),\n    lt: f('<'),\n    gte: f('>='),\n    gt: f('>'),\n    null: f('attribute_not_exists'),\n    notNull: f('attribute_exists'),\n    contains: f('contains'),\n    notContains: f('NOT contains'),\n    in: f('IN'),\n    beginsWith: f('begins_with'),\n    between: f('BETWEEN')\n  };\n};\n\nvar Scan = module.exports = function (table, serializer) {\n  this.table = table;\n  this.serializer = serializer;\n  this.options = {\n    loadAll: false\n  };\n  this.request = {};\n};\n\nScan.prototype.limit = function (num) {\n  if (num <= 0) {\n    throw new Error('Limit must be greater than 0');\n  }\n\n  this.request.Limit = num;\n  return this;\n};\n\nScan.prototype.addFilterCondition = function (condition) {\n  var expressionAttributeNames = _.merge({}, condition.attributeNames, this.request.ExpressionAttributeNames);\n\n  var expressionAttributeValues = _.merge({}, condition.attributeValues, this.request.ExpressionAttributeValues);\n\n  if (!_.isEmpty(expressionAttributeNames)) {\n    this.request.ExpressionAttributeNames = expressionAttributeNames;\n  }\n\n  if (!_.isEmpty(expressionAttributeValues)) {\n    this.request.ExpressionAttributeValues = expressionAttributeValues;\n  }\n\n  if (_.isString(this.request.FilterExpression)) {\n    this.request.FilterExpression = this.request.FilterExpression + ' AND (' + condition.statement + ')';\n  } else {\n    this.request.FilterExpression = '(' + condition.statement + ')';\n  }\n\n  return this;\n};\n\nScan.prototype.startKey = function (hashKey, rangeKey) {\n  this.request.ExclusiveStartKey = this.serializer.buildKey(hashKey, rangeKey, this.table.schema);\n  return this;\n};\n\nScan.prototype.attributes = function (attrs) {\n  if (!_.isArray(attrs)) {\n    attrs = [attrs];\n  }\n\n  var expressionAttributeNames = _.reduce(attrs, function (result, attr) {\n    var path = '#' + attr;\n    result[path] = attr;\n    return result;\n  }, {});\n\n  this.request.ProjectionExpression = _.keys(expressionAttributeNames).join(',');\n  this.request.ExpressionAttributeNames = _.merge({}, expressionAttributeNames, this.request.ExpressionAttributeNames);\n  return this;\n};\n\nScan.prototype.select = function (value) {\n  this.request.Select = value;\n  return this;\n};\n\nScan.prototype.returnConsumedCapacity = function (value) {\n  if (_.isUndefined(value)) {\n    value = 'TOTAL';\n  }\n\n  this.request.ReturnConsumedCapacity = value;\n  return this;\n};\n\nScan.prototype.segments = function (segment, totalSegments) {\n  this.request.Segment = segment;\n  this.request.TotalSegments = totalSegments;\n  return this;\n};\n\nScan.prototype.where = function (keyName) {\n  return internals.keyCondition(keyName, this.table.schema, this);\n};\n\nScan.prototype.filterExpression = function (expression) {\n  this.request.FilterExpression = expression;\n  return this;\n};\n\nScan.prototype.expressionAttributeValues = function (data) {\n  this.request.ExpressionAttributeValues = data;\n  return this;\n};\n\nScan.prototype.expressionAttributeNames = function (data) {\n  this.request.ExpressionAttributeNames = data;\n  return this;\n};\n\nScan.prototype.projectionExpression = function (data) {\n  this.request.ProjectionExpression = data;\n  return this;\n};\n\nScan.prototype.exec = function (callback) {\n  var self = this;\n\n  var runScan = function (params, callback) {\n    self.table.runScan(params, callback);\n  };\n\n  return utils.paginatedRequest(self, runScan, callback);\n};\n\nScan.prototype.loadAll = function () {\n  this.options.loadAll = true;\n  return this;\n};\n\nScan.prototype.buildRequest = function () {\n  return _.merge({}, this.request, {\n    TableName: this.table.tableName()\n  });\n};","map":null,"metadata":{},"sourceType":"script"}